print("\n# CAP2 - EXERCICIO 2.2. QUEST√ÉO 1 ~ QUEST√ÉO 5")

#ATIVIDADE 2

import sympy as sp

# 1. Definindo as vari√°veis simb√≥licas
x1, x2 = sp.symbols('x1 x2')

# 2. Fun√ß√µes do exerc√≠cio 2.2
funcoes = [
    (1/2)*x1**2 + (9/2)*x2**2,
    (1/3)*x1**3 + x2**3 - x1 - x2,
    (x1 - 2)**4 + (x1 - 2)**2*(x2 + 1)**2 + (x2 + 1)**2,
    x1**2 + 2*x1*x2 + 2*x2**2,
    x1**2 - x1*x2 + 2*x2**2 - 2*x1 + sp.exp(x1 + x2)
]

# 3. Pontos especificados
pontos = [
    {x1: 0, x2: 0},
    {x1: 9, x2: 1},
    {x1: 2, x2: -1},
    {x1: 1, x2: 1},
    {x1: 0, x2: 0}
]

# 4. T√≠tulos
titulos = [
    "Exerc√≠cio 2.2.1",
    "Exerc√≠cio 2.2.2",
    "Exerc√≠cio 2.2.3",
    "Exerc√≠cio 2.2.4",
    "Exerc√≠cio 2.2.5"
]

# 5. Dire√ß√£o para curvatura
d = sp.Matrix([1, 1])

# 6. Loop para resolver todos os exerc√≠cios
for i, f in enumerate(funcoes):
    print("\n" + "="*60)
    print(f"üîç {titulos[i]}")
    print("="*60)

    # Gradiente
    grad = [sp.diff(f, var) for var in (x1, x2)]
    print("Gradiente:")
    print(grad)

    # Hessiana
    hess = sp.hessian(f, (x1, x2))
    print("\nHessiana:")
    sp.pprint(hess)

    # Ponto espec√≠fico
    ponto = pontos[i]
    hess_at_ponto = hess.subs(ponto)
    print(f"\nHessiana no ponto {ponto}:")
    sp.pprint(hess_at_ponto)

    # Autovalores
    eigenvals = hess_at_ponto.eigenvals()
    print("\nAutovalores:")
    print(eigenvals)

    # Curvatura na dire√ß√£o d = [1, 1]
    curvatura = (d.T * hess_at_ponto * d)[0]
    print(f"\nCurvatura na dire√ß√£o d = [1, 1]: {curvatura}")

    # Classifica√ß√£o da fun√ß√£o
    autovalores = list(eigenvals.keys())
    if all(val.is_real for val in autovalores):
        if all(val > 0 for val in autovalores):
            print("‚úîÔ∏è A fun√ß√£o √© estritamente convexa nesse ponto (Hessiana definida positiva)")
        elif all(val < 0 for val in autovalores):
            print("‚úîÔ∏è A fun√ß√£o √© estritamente c√¥ncava nesse ponto (Hessiana definida negativa)")
        elif all(val >= 0 for val in autovalores):
            print("‚ö†Ô∏è A fun√ß√£o √© convexa, mas n√£o estritamente (Hessiana semidefinida positiva)")
        elif all(val <= 0 for val in autovalores):
            print("‚ö†Ô∏è A fun√ß√£o √© c√¥ncava, mas n√£o estritamente (Hessiana semidefinida negativa)")
        else:
            print("‚ùå A fun√ß√£o n√£o √© convexa nem c√¥ncava (Hessiana indefinida)")
    else:
        print("‚ö†Ô∏è Autovalores n√£o reais ‚Äî an√°lise de convexidade inconclusiva")


# ATIVIDADE 5

#5.1
import sympy as sp
from scipy.optimize import minimize_scalar

# 1. Definindo a vari√°vel simb√≥lica
x = sp.Symbol('x')
f = x ** 2 + 1 / (x - 2)

# 2. Derivada (gradiente)
df = sp.diff(f, x)
print("Gradiente (f'):")
sp.pprint(df)

# 3. Segunda derivada (Hessiana em R¬π)
d2f = sp.diff(df, x)
print("\nSegunda derivada (f''):")
sp.pprint(d2f)

# 4. Tentando encontrar pontos cr√≠ticos reais (df = 0)
critical_points = sp.solve(df, x)

# 5. Filtrar apenas os pontos reais e diferentes de x = 2
valid_points = [
    pt for pt in critical_points
    if pt.is_real and not sp.simplify(pt - 2) == 0
]

print("\nPontos cr√≠ticos reais (v√°lidos):")
print(valid_points)

# 6. An√°lise da segunda derivada nos pontos cr√≠ticos
for pt in valid_points:
    second_derivative_value = d2f.subs(x, pt)
    print(f"\nNo ponto x = {pt}: f''(x) = {second_derivative_value}")
    if second_derivative_value > 0:
        print("‚Üí M√≠nimo local")
    elif second_derivative_value < 0:
        print("‚Üí M√°ximo local")
    else:
        print("‚Üí Ponto de inflex√£o")

# 7. Caso n√£o haja ponto cr√≠tico real, encontrar m√≠nimo num√©rico
if not valid_points:
    print("\nN√£o h√° ponto cr√≠tico real vi√°vel. Fazendo busca num√©rica no intervalo (2.01, 5)...")


    def f_num(x_val):
        return x_val ** 2 + 1 / (x_val - 2)


    result = minimize_scalar(f_num, bounds=(2.01, 5), method='bounded')

    print(f"\nM√≠nimo num√©rico aproximado:")
    print(f"x ‚âà {result.x:.4f}")
    print(f"f(x) ‚âà {result.fun:.4f}")

#5.2
import sympy as sp

# Definindo as vari√°veis
x1, x2 = sp.symbols('x1 x2')

# Definindo a fun√ß√£o objetivo
f = (1 / 3) * x1 ** 3 + x2 ** 3 - x1 - x2

# 1. Calculando o gradiente
grad_f = [sp.diff(f, var) for var in (x1, x2)]
print("Gradiente:")
print(grad_f)

# 2. Calculando a matriz Hessiana
hess_f = sp.hessian(f, (x1, x2))
print("\nHessiana:")
sp.pprint(hess_f)

# 3. Encontrando os pontos cr√≠ticos (gradiente = 0)
critical_points = sp.solve(grad_f, (x1, x2))
print("\nPontos cr√≠ticos:")
print(critical_points)

# 4. Verificando as condi√ß√µes de segunda ordem (autovalores da Hessiana)
print("\nAn√°lise dos pontos cr√≠ticos:")
for point in critical_points:
    hess_at_point = hess_f.subs({x1: point[0], x2: point[1]})
    eigenvals = hess_at_point.eigenvals()

    print(f"\nPonto cr√≠tico: {point}")
    print("Hessiana no ponto:")
    sp.pprint(hess_at_point)
    print("Autovalores:", eigenvals)

    # Classifica√ß√£o
    eigenvalues_list = list(eigenvals.keys())
    if all(val > 0 for val in eigenvalues_list):
        print("‚Üí M√≠nimo local")
    elif all(val < 0 for val in eigenvalues_list):
        print("‚Üí M√°ximo local")
    else:
        print("‚Üí Ponto de sela")

#5.3
import sympy as sp
from scipy.optimize import minimize_scalar

# 1. Definindo a vari√°vel simb√≥lica
x = sp.Symbol('x')
f = x ** 2 + 1 / (x - 2)

# 2. Derivada (gradiente)
df = sp.diff(f, x)
print("Gradiente (f'):")
sp.pprint(df)

# 3. Segunda derivada (Hessiana em R¬π)
d2f = sp.diff(df, x)
print("\nSegunda derivada (f''):")
sp.pprint(d2f)

# 4. Tentando encontrar pontos cr√≠ticos reais (df = 0)
critical_points = sp.solve(df, x)

# 5. Filtrar apenas os pontos reais e diferentes de x = 2
valid_points = [
    pt for pt in critical_points
    if pt.is_real and not sp.simplify(pt - 2) == 0
]

print("\nPontos cr√≠ticos reais (v√°lidos):")
print(valid_points)

# 6. An√°lise da segunda derivada nos pontos cr√≠ticos
for pt in valid_points:
    second_derivative_value = d2f.subs(x, pt)
    print(f"\nNo ponto x = {pt}: f''(x) = {second_derivative_value}")
    if second_derivative_value > 0:
        print("‚Üí M√≠nimo local")
    elif second_derivative_value < 0:
        print("‚Üí M√°ximo local")
    else:
        print("‚Üí Ponto de inflex√£o")

# 7. Caso n√£o haja ponto cr√≠tico real, encontrar m√≠nimo num√©rico
if not valid_points:
    print("\nN√£o h√° ponto cr√≠tico real vi√°vel. Fazendo busca num√©rica no intervalo (2.01, 5)...")


    def f_num(x_val):
        return x_val ** 2 + 1 / (x_val - 2)


    result = minimize_scalar(f_num, bounds=(2.01, 5), method='bounded')

    print(f"\nM√≠nimo num√©rico aproximado:")
    print(f"x ‚âà {result.x:.4f}")
    print(f"f(x) ‚âà {result.fun:.4f}")

#5.4
import sympy as sp

# 1. Definindo as vari√°veis simb√≥licas
x1, x2 = sp.symbols('x1 x2')
f = x1**6 - 3*x1**4*x2**2 + 3*x1**2*x2**4 - x2**6

# 2. Gradiente (primeiras derivadas)
grad_f = [sp.diff(f, var) for var in (x1, x2)]
print("Gradiente:")
print(grad_f)

# 3. Hessiana (matriz de segundas derivadas)
hess_f = sp.hessian(f, (x1, x2))
print("\nHessiana:")
sp.pprint(hess_f)

# 4. Pontos cr√≠ticos (resolvendo gradiente = 0)
critical_points = sp.solve(grad_f, (x1, x2), dict=True)
valid_points = [pt for pt in critical_points if x1 in pt and x2 in pt]

print("\nPontos cr√≠ticos encontrados:")
print(valid_points)

# 5. Avalia√ß√£o da Hessiana e autovalores
for pt in valid_points:
    point_val = (pt[x1], pt[x2])
    hess_at_point = hess_f.subs(pt)
    eigenvals = hess_at_point.eigenvals()

    print(f"\nAn√°lise no ponto cr√≠tico: {point_val}")
    print("Hessiana avaliada no ponto:")
    sp.pprint(hess_at_point)
    print("Autovalores da Hessiana:", eigenvals)

    # Classifica√ß√£o
    eigenvalues_list = list(eigenvals.keys())
    if all(val > 0 for val in eigenvalues_list):
        print("‚Üí M√≠nimo local")
    elif all(val < 0 for val in eigenvalues_list):
        print("‚Üí M√°ximo local")
    elif all(val == 0 for val in eigenvalues_list):
        print("‚Üí Condi√ß√£o de segunda ordem inconclusiva (todos os autovalores s√£o zero)")
    else:
        print("‚Üí Ponto de sela ou condi√ß√£o inconclusiva")

#5.5
import sympy as sp

# 1. Definindo vari√°veis simb√≥licas
x1, x2 = sp.symbols('x1 x2')

# 2. Lista das fun√ß√µes (2.2.1 a 2.2.5)
funcoes = [
    (1/2)*x1**2 + (9/2)*x2**2,
    (1/3)*x1**3 + x2**3 - x1 - x2,
    (x1 - 2)**4 + (x1 - 2)**2 * (x2 + 1)**2 + (x2 + 1)**2,
    x1**2 + 2*x1*x2 + 2*x2**2,
    x1**2 - x1*x2 + 2*x2**2 - 2*x1 + sp.exp(x1 + x2)
]

# 3. T√≠tulos para exibir
titulos = [
    "Exerc√≠cio 2.2.1",
    "Exerc√≠cio 2.2.2",
    "Exerc√≠cio 2.2.3",
    "Exerc√≠cio 2.2.4",
    "Exerc√≠cio 2.2.5"
]

# 4. An√°lise de cada fun√ß√£o
for i, f in enumerate(funcoes):
    print("\n" + "="*60)
    print(f"üîç {titulos[i]}")
    print("="*60)

    # Gradiente
    grad = [sp.diff(f, var) for var in (x1, x2)]
    print("Gradiente:")
    print(grad)

    # Hessiana
    hess = sp.hessian(f, (x1, x2))
    print("\nHessiana:")
    sp.pprint(hess)

    # Pontos cr√≠ticos
    if i == 4:  # caso especial para fun√ß√£o com exponencial (2.2.5)
        from sympy import nsolve
        try:
            ponto_numerico = sp.nsolve(grad, (x1, x2), (0, 0))
            pt = {x1: ponto_numerico[0], x2: ponto_numerico[1]}
            pontos_criticos = [pt]
            print("\nüî¢ Ponto cr√≠tico aproximado numericamente:")
            print(pt)
        except Exception as e:
            print("‚ùå Erro ao resolver numericamente:", e)
            pontos_criticos = []
    else:
        pontos_criticos = sp.solve(grad, (x1, x2), dict=True)
        print("\nPonto(s) cr√≠tico(s):")
        print(pontos_criticos)

    # An√°lise dos pontos cr√≠ticos
    for pt in pontos_criticos:
        if x1 in pt and x2 in pt:
            ponto_val = (pt[x1], pt[x2])
            hess_at_pt = hess.subs(pt)
            eigenvals = hess_at_pt.eigenvals()

            print(f"\n‚Üí An√°lise no ponto {ponto_val}:")
            print("Hessiana avaliada:")
            sp.pprint(hess_at_pt)
            print("Autovalores:", eigenvals)

            autovalores = list(eigenvals.keys())
            if all(val.is_real for val in autovalores):
                if all(val > 0 for val in autovalores):
                    print("‚úîÔ∏è M√≠nimo local (e possivelmente global)")
                elif all(val < 0 for val in autovalores):
                    print("‚úîÔ∏è M√°ximo local")
                elif all(val == 0 for val in autovalores):
                    print("‚ö†Ô∏è Condi√ß√£o de segunda ordem inconclusiva (valores nulos)")
                else:
                    print("‚ö†Ô∏è Ponto de sela ou condi√ß√£o mista")
            else:
                print("‚ö†Ô∏è Autovalores complexos ‚Äî an√°lise de segunda ordem inconclusiva")

